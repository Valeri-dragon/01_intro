/**
 * var отличие от let в том, что перменные всплывают до их объявления/
 * Если бы в примере ниже было let вместо var получили бы ошибку в коде, так как к let переменным нельзя обращаться до того как они бвли объявлены.
 * function doSomethingStupid() {
 * console.log(x) // ошибок не будет, а консоль выведет undefined
 * var x = 123;
 * console.log(x) // 123, как и можно было ожидать
 * }
 * код выше можно переписать так
 * function doSomethingStupid() {
 * // Объявление (Н присваивание) вспыло...
 *  var x;
console.log(x);
//... но присваивание при этом осталось на месте
x = 123;
console.log(x)
}

Всплытие полностью игнорирует вложенные блоки.
Всплытие присуще не только var переменным, но и функциям.
// Функцию можно вызвать до объявления (такой трюк сработает только для функции function Name (){}, то есть для именованных функций),
//  JavaScript позволяет так делать
doSomethingStupid1();
// function Declaration  Именованые функции
function doSomethingStupid1() {
console.log(x) // ошибок не будет, а консоль выведет undefined
 var x = 123;
 console.log(x) // 123, как и можно было ожидать
}
в случае если мы присваиваем аннонимную функцию, то есть функцию без имени в перемнную или константу вести себя она будет ровно также как обычная перменная или константа
doSomethingStupid2(); // получим ошибку, потому что функция анонимная, присвоена в let и работает она по тем же правилам, что и let перменная
то есть использовать её до объявления, мы не можем
// Function Expression  присвоение функции в переменную или константу let/const name = () =>{}
let  doSomethingStupid2 = function () {
console.log(x) // ошибок не будет, а консоль выведет undefined
 var x = 123;
 console.log(x) // 123, как и можно было ожидать
}
 */